
Please look through the following GitHub Problem Description and the Skeleton of Relevant Files.
Identify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.
For each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.

### GitHub Problem Description ###
Please support header rows in RestructuredText output
### Description

It would be great if the following would work:

```Python
>>> from astropy.table import QTable
>>> import astropy.units as u
>>> import sys
>>> tbl = QTable({'wave': [350,950]*u.nm, 'response': [0.7, 1.2]*u.count})
>>> tbl.write(sys.stdout,  format="ascii.rst")
===== ========
 wave response
===== ========
350.0      0.7
950.0      1.2
===== ========
>>> tbl.write(sys.stdout,  format="ascii.fixed_width", header_rows=["name", "unit"])
|  wave | response |
|    nm |       ct |
| 350.0 |      0.7 |
| 950.0 |      1.2 |
>>> tbl.write(sys.stdout,  format="ascii.rst", header_rows=["name", "unit"])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python3/dist-packages/astropy/table/connect.py", line 129, in __call__
    self.registry.write(instance, *args, **kwargs)
  File "/usr/lib/python3/dist-packages/astropy/io/registry/core.py", line 369, in write
    return writer(data, *args, **kwargs)
  File "/usr/lib/python3/dist-packages/astropy/io/ascii/connect.py", line 26, in io_write
    return write(table, filename, **kwargs)
  File "/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py", line 856, in write
    writer = get_writer(Writer=Writer, fast_writer=fast_writer, **kwargs)
  File "/usr/lib/python3/dist-packages/astropy/io/ascii/ui.py", line 800, in get_writer
    writer = core._get_writer(Writer, fast_writer, **kwargs)
  File "/usr/lib/python3/dist-packages/astropy/io/ascii/core.py", line 1719, in _get_writer
    writer = Writer(**writer_kwargs)
TypeError: RST.__init__() got an unexpected keyword argument 'header_rows'
```


### Additional context

RestructuredText output is a great way to fill autogenerated documentation with content, so having this flexible makes the life easier `:-)`




### Skeleton of Relevant Files ###

### File: astropy/io/ascii/core.py ###
```python
# Licensed under a 3-clause BSD style license - see LICENSE.rst

# Global dictionary mapping format arg to the corresponding Reader class
FORMAT_CLASSES = {}

# Similar dictionary for fast readers
FAST_CLASSES = {}


def _check_multidim_table(table, max_ndim):
...

class CsvWriter:

    # Random 16-character string that gets injected instead of any
    # empty fields and is then replaced post-write with doubled-quotechar.
    # Created with:
    # ''.join(random.choice(string.printable[:90]) for _ in range(16))
    replace_sentinel = "2b=48Av%0-V3p>bX"

    def __init__(self, csvfile=None, **kwargs):
...
    def writerow(self, values):
...
    def writerows(self, values_list):
...
    def _writerow(self, writerow_func, values, has_empty):
...

class MaskedConstant(numpy.ma.core.MaskedConstant):

    def __hash__(self):
...
    def __copy__(self):
...
    def __deepcopy__(self, memo):
...

masked = MaskedConstant()


class InconsistentTableError(ValueError):
    pass


class OptionalTableImportError(ImportError):
    pass


class ParameterError(NotImplementedError):
    pass


class FastOptionsError(NotImplementedError):
    pass


class NoType:
    pass


class StrType(NoType):
    pass


class NumType(NoType):
    pass


class FloatType(NumType):
    pass


class BoolType(NoType):
    pass


class IntType(NumType):
    pass


class AllType(StrType, FloatType, IntType):
    pass


class Column:

    def __init__(self, name):
...

class BaseInputter:

    encoding = None

    def get_lines(self, table, newline=None):
...
    def process_lines(self, lines):
...

class BaseSplitter:

    delimiter = None

    def process_line(self, line):
...
    def process_val(self, val):
...
    def __call__(self, lines):
...
    def join(self, vals):
...

class DefaultSplitter(BaseSplitter):

    delimiter = " "
    quotechar = '"'
    doublequote = True
    escapechar = None
    quoting = csv.QUOTE_MINIMAL
    skipinitialspace = True
    csv_writer = None
    csv_writer_out = StringIO()

    def process_line(self, line):
...
    def process_val(self, val):
...
    def __call__(self, lines):
...
    def join(self, vals):
...

def _replace_tab_with_space(line, escapechar, quotechar):
...

def _get_line_index(line_or_func, lines):
...

class BaseHeader:

    auto_format = "col{}"
    start_line = None
    comment = None
    splitter_class = DefaultSplitter
    names = None
    write_comment = False
    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]

    def __init__(self):
...
    def _set_cols_from_names(self):
...
    def update_meta(self, lines, meta):
...
    def get_cols(self, lines):
...
    def process_lines(self, lines):
...
    def write_comments(self, lines, meta):
...
    def write(self, lines):
...
    @property
    def colnames(self):
...
    def remove_columns(self, names):
...
    def rename_column(self, name, new_name):
...
    def get_type_map_key(self, col):
...
    def get_col_type(self, col):
...
    def check_column_names(self, names, strict_names, guessing):
...

class BaseData:

    start_line = None
    end_line = None
    comment = None
    splitter_class = DefaultSplitter
    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]
    fill_include_names = None
    fill_exclude_names = None
    fill_values = [(masked, "")]
    formats = {}

    def __init__(self):
...
    def process_lines(self, lines):
...
    def get_data_lines(self, lines):
...
    def get_str_vals(self):
...
    def masks(self, cols):
...
    def _set_fill_values(self, cols):
...
    def _set_masks(self, cols):
...
    def _replace_vals(self, cols):
...
    def str_vals(self):
...
    def write(self, lines):
...
    def _set_col_formats(self):
...

def convert_numpy(numpy_type):
...

class BaseOutputter:

    # User-defined converters which gets set in ascii.ui if a `converter` kwarg
    # is supplied.
    converters = {}

    # Derived classes must define default_converters and __call__

    @staticmethod
    def _validate_and_copy(col, converters):
...
    def _convert_vals(self, cols):
...

def _deduplicate_names(names):
...

class TableOutputter(BaseOutputter):

    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]

    def __call__(self, cols, meta):
...

class MetaBaseReader(type):
    def __init__(cls, name, bases, dct):
...

def _is_number(x):
...

def _apply_include_exclude_names(table, names, include_names, exclude_names):
...

class BaseReader(metaclass=MetaBaseReader):

    names = None
    include_names = None
    exclude_names = None
    strict_names = False
    guessing = False
    encoding = None

    header_class = BaseHeader
    data_class = BaseData
    inputter_class = BaseInputter
    outputter_class = TableOutputter

    # Max column dimension that writer supports for this format. Exceptions
    # include ECSV (no limit) and HTML (max_ndim=2).
    max_ndim = 1

    def __init__(self):
...
    def _check_multidim_table(self, table):
...
    def read(self, table):
...
    def inconsistent_handler(self, str_vals, ncols):
...
    @property
    def comment_lines(self):
...
    def update_table_data(self, table):
...
    def write_header(self, lines, meta):
...
    def write(self, table):
...

class ContinuationLinesInputter(BaseInputter):

    continuation_char = "\\"
    replace_char = " "
    # If no_continue is not None then lines matching this regex are not subject
    # to line continuation.  The initial use case here is Daophot.  In this
    # case the continuation character is just replaced with replace_char.
    no_continue = None

    def process_lines(self, lines):
...

class WhitespaceSplitter(DefaultSplitter):
    def process_line(self, line):
...

extra_reader_pars = (
    "Reader",
    "Inputter",
    "Outputter",
    "delimiter",
    "comment",
    "quotechar",
    "header_start",
    "data_start",
    "data_end",
    "converters",
    "encoding",
    "data_Splitter",
    "header_Splitter",
    "names",
    "include_names",
    "exclude_names",
    "strict_names",
    "fill_values",
    "fill_include_names",
    "fill_exclude_names",
)


def _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):
...

extra_writer_pars = (
    "delimiter",
    "comment",
    "quotechar",
    "formats",
    "strip_whitespace",
    "names",
    "include_names",
    "exclude_names",
    "fill_values",
    "fill_include_names",
    "fill_exclude_names",
)


def _get_writer(Writer, fast_writer, **kwargs):

```

### File: astropy/io/ascii/ui.py ###
```python
# Licensed under a 3-clause BSD style license - see LICENSE.rst

_read_trace = []

# Default setting for guess parameter in read()
_GUESS = True


def _probably_html(table, maxchars=100000):
...

def set_guess(guess):
...

def get_reader(Reader=None, Inputter=None, Outputter=None, **kwargs):
...

def _get_format_class(format, ReaderWriter, label):
...

def _get_fast_reader_dict(kwargs):
...

def _validate_read_write_kwargs(read_write, **kwargs):
...

def _expand_user_if_path(argument):
...

def read(table, guess=None, **kwargs):
...

read.__doc__ = core.READ_DOCSTRING


def _guess(table, read_kwargs, format, fast_reader):
...

def _get_guess_kwargs_list(read_kwargs):
...

def _read_in_chunks(table, **kwargs):
...

def _read_in_chunks_generator(table, chunk_size, **kwargs):
...

extra_writer_pars = (
    "delimiter",
    "comment",
    "quotechar",
    "formats",
    "names",
    "include_names",
    "exclude_names",
    "strip_whitespace",
)


def get_writer(Writer=None, fast_writer=True, **kwargs):
...

def write(
    table,
    output=None,
    format=None,
    Writer=None,
    fast_writer=True,
    *,
    overwrite=False,
    **kwargs,
):
...

write.__doc__ = core.WRITE_DOCSTRING


def get_read_trace():

```

### File: astropy/io/ascii/connect.py ###
```python
# Licensed under a 3-clause BSD style license - see LICENSE.rst
# This file connects the readers/writers to the astropy.table.Table class



__all__ = []


def io_read(format, filename, **kwargs):
...

def io_write(format, table, filename, **kwargs):
...

def io_identify(suffix, origin, filepath, fileobj, *args, **kwargs):
...

def _get_connectors_table():

```


###

Please provide the complete set of locations as either a class name, a function name, or a variable name.
Note that if you include a class, you do not need to list its specific methods.
You can include either the entire class or don't include the class name and instead include specific methods in the class.
### Pay attention that the response should be wrapped with ``` in accordance to these following example:
```
full_path1/file1.py
function: my_function_1
class: MyClass1
function: MyClass2.my_method

full_path2/file2.py
variable: my_var
function: MyClass3.my_method

full_path3/file3.py
function: my_function_2
function: my_function_3
function: MyClass4.my_method_1
class: MyClass5
```

Return just the locations.

