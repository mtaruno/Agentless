Compressed file contents:
{'astropy/modeling/separable.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n__all__ = ["is_separable", "separability_matrix"]\n\n\ndef is_separable(transform):\n...\n\ndef separability_matrix(transform):\n...\n\ndef _compute_n_outputs(left, right):\n...\n\ndef _arith_oper(left, right):\n...\n\ndef _coord_matrix(model, pos, noutp):\n...\n\ndef _cstack(left, right):\n...\n\ndef _cdot(left, right):\n...\n\ndef _separable(transform):\n...\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {\'&\': _cstack, \'|\': _cdot, \'+\': _arith_oper, \'-\': _arith_oper,\n              \'*\': _arith_oper, \'/\': _arith_oper, \'**\': _arith_oper}', 'astropy/modeling/fitting.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'LinearLSQFitter\', \'LevMarLSQFitter\', \'FittingWithOutlierRemoval\',\n           \'SLSQPLSQFitter\', \'SimplexLSQFitter\', \'JointFitter\', \'Fitter\',\n           "ModelLinearityError", "ModelsError"]\n\n\n# Statistic functions implemented in `astropy.modeling.statistic.py\nSTATISTICS = [leastsquare]\n\n# Optimizers implemented in `astropy.modeling.optimizers.py\nOPTIMIZERS = [Simplex, SLSQP]\n\n\nclass Covariance():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, params):\n...\n\nclass StandardDeviations():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def _calc_stds(self, cov_matrix):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, param):\n...\n\nclass ModelsError(Exception):\n    pass\n\n\nclass ModelLinearityError(ModelsError):\n    pass\n\n\nclass UnsupportedConstraintError(ModelsError, ValueError):\n    pass\n\n\nclass _FitterMeta(abc.ABCMeta):\n\n    registry = set()\n\n    def __new__(mcls, name, bases, members):\n...\n\ndef fitter_unit_support(func):\n...\n\nclass Fitter(metaclass=_FitterMeta):\n\n    supported_constraints = []\n\n    def __init__(self, optimizer, statistic):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(*args):\n...\n    @abc.abstractmethod\n    def __call__(self):\n...\n\n# TODO: I have ongoing branch elsewhere that\'s refactoring this module so that\n# all the fitter classes in here are Fitter subclasses.  In the meantime we\n# need to specify that _FitterMeta is its metaclass.\nclass LinearLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\']\n    supports_masked_input = True\n\n    def __init__(self, calc_uncertainties=False):\n...\n    @staticmethod\n    def _is_invertible(m):\n...\n    def _add_fitting_uncertainties(self, model, a, n_coeff, x, y, z=None,\n                                   resids=None):\n...\n    @staticmethod\n    def _deriv_with_constraints(model, param_indices, x=None, y=None):\n...\n    def _map_domain_window(self, model, x, y=None):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, rcond=None):\n...\n\nclass FittingWithOutlierRemoval:\n\n    def __init__(self, fitter, outlier_func, niter=3, **outlier_kwargs):\n...\n    def __str__(self):\n...\n    def __repr__(self):\n...\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass LevMarLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\', \'tied\', \'bounds\']\n\n    def __init__(self, calc_uncertainties=False):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(model, cov_matrix):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None,\n                 maxiter=DEFAULT_MAXITER, acc=DEFAULT_ACC,\n                 epsilon=DEFAULT_EPS, estimate_jacobian=False):\n...\n    @staticmethod\n    def _wrap_deriv(params, model, weights, x, y, z=None):\n...\n\nclass SLSQPLSQFitter(Fitter):\n\n    supported_constraints = SLSQP.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass SimplexLSQFitter(Fitter):\n\n    supported_constraints = Simplex.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass JointFitter(metaclass=_FitterMeta):\n\n    def __init__(self, models, jointparameters, initvals):\n...\n    def model_to_fit_params(self):\n...\n    def objective_function(self, fps, *args):\n...\n    def _verify_input(self):\n...\n    def __call__(self, *args):\n...\n\ndef _convert_input(x, y, z=None, n_models=1, model_set_axis=0):\n...\n\n# TODO: These utility functions are really particular to handling\n# bounds/tied/fixed constraints for scipy.optimize optimizers that do not\n# support them inherently; this needs to be reworked to be clear about this\n# distinction (and the fact that these are not necessarily applicable to any\n# arbitrary fitter--as evidenced for example by the fact that JointFitter has\n# its own versions of these)\n# TODO: Most of this code should be entirely rewritten; it should not be as\n# inefficient as it is.\ndef fitter_to_model_params(model, fps):\n...\n\n@deprecated(\'5.1\', \'private method: _fitter_to_model_params has been made public now\')\ndef _fitter_to_model_params(model, fps):\n...\n\ndef model_to_fit_params(model):\n...\n\n@deprecated(\'5.1\', \'private method: _model_to_fit_params has been made public now\')\ndef _model_to_fit_params(model):\n...\n\ndef _validate_constraints(supported_constraints, model):\n...\n\ndef _validate_model(model, supported_constraints):\n...\n\ndef populate_entry_points(entry_points):\n...\n\ndef _populate_ep():\n', 'astropy/modeling/rotations.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'RotateCelestial2Native\', \'RotateNative2Celestial\', \'Rotation2D\',\n           \'EulerAngleRotation\', \'RotationSequence3D\', \'SphericalRotationSequence\']\n\n\ndef _create_matrix(angles, axes_order):\n...\n\ndef spherical2cartesian(alpha, delta):\n...\n\ndef cartesian2spherical(x, y, z):\n...\n\nclass RotationSequence3D(Model):\n    standard_broadcasting = False\n    _separable = False\n    n_inputs = 3\n    n_outputs = 3\n\n    angles = Parameter(default=[], getter=_to_orig_unit, setter=_to_radian, description="Angles of rotation in deg in the order of axes_order")\n\n    def __init__(self, angles, axes_order, name=None):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, x, y, z, angles):\n...\n\nclass SphericalRotationSequence(RotationSequence3D):\n    def __init__(self, angles, axes_order, name=None, **kwargs):\n...\n    @property\n    def n_inputs(self):\n...\n    @property\n    def n_outputs(self):\n...\n    def evaluate(self, lon, lat, angles):\n...\n\nclass _EulerRotation:\n\n    _separable = False\n\n    def evaluate(self, alpha, delta, phi, theta, psi, axes_order):\n...\n    _input_units_strict = True\n\n    _input_units_allow_dimensionless = True\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n\nclass EulerAngleRotation(_EulerRotation, Model):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    phi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="1st Euler angle (Quantity or value in deg)")\n    theta = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="2nd Euler angle (Quantity or value in deg)")\n    psi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="3rd Euler angle (Quantity or value in deg)")\n\n    def __init__(self, phi, theta, psi, axes_order, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, alpha, delta, phi, theta, psi):\n...\n\nclass _SkyRotation(_EulerRotation, Model):\n\n    lon = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Latitude")\n    lat = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longtitude")\n    lon_pole = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longitude of a pole")\n\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def _evaluate(self, phi, theta, lon, lat, lon_pole):\n...\n\nclass RotateNative2Celestial(_SkyRotation):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, phi_N, theta_N, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass RotateCelestial2Native(_SkyRotation):\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, alpha_C, delta_C, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass Rotation2D(Model):\n    n_inputs = 2\n    n_outputs = 2\n\n    _separable = False\n\n    angle = Parameter(default=0.0, getter=_to_orig_unit, setter=_to_radian,\n    description="Angle of rotation (Quantity or value in deg)")\n\n    def __init__(self, angle=angle, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    @classmethod\n    def evaluate(cls, x, y, angle):\n...\n    @staticmethod\n    def _compute_matrix(angle):\n'}














Model found locs
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']














File Names:
['astropy/modeling/separable.py', 'astropy/modeling/fitting.py', 'astropy/modeling/rotations.py']














Locs:
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']














Model Found Locs Separated:
['']














['']














['']














File Names:
['astropy/modeling/separable.py', 'astropy/modeling/fitting.py', 'astropy/modeling/rotations.py']














Locs:
[]














Model Found Locs Separated:
['']














['']














['']














Compressed file contents:
{'astropy/io/ascii/core.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Global dictionary mapping format arg to the corresponding Reader class\nFORMAT_CLASSES = {}\n\n# Similar dictionary for fast readers\nFAST_CLASSES = {}\n\n\ndef _check_multidim_table(table, max_ndim):\n...\n\nclass CsvWriter:\n\n    # Random 16-character string that gets injected instead of any\n    # empty fields and is then replaced post-write with doubled-quotechar.\n    # Created with:\n    # \'\'.join(random.choice(string.printable[:90]) for _ in range(16))\n    replace_sentinel = "2b=48Av%0-V3p>bX"\n\n    def __init__(self, csvfile=None, **kwargs):\n...\n    def writerow(self, values):\n...\n    def writerows(self, values_list):\n...\n    def _writerow(self, writerow_func, values, has_empty):\n...\n\nclass MaskedConstant(numpy.ma.core.MaskedConstant):\n\n    def __hash__(self):\n...\n    def __copy__(self):\n...\n    def __deepcopy__(self, memo):\n...\n\nmasked = MaskedConstant()\n\n\nclass InconsistentTableError(ValueError):\n    pass\n\n\nclass OptionalTableImportError(ImportError):\n    pass\n\n\nclass ParameterError(NotImplementedError):\n    pass\n\n\nclass FastOptionsError(NotImplementedError):\n    pass\n\n\nclass NoType:\n    pass\n\n\nclass StrType(NoType):\n    pass\n\n\nclass NumType(NoType):\n    pass\n\n\nclass FloatType(NumType):\n    pass\n\n\nclass BoolType(NoType):\n    pass\n\n\nclass IntType(NumType):\n    pass\n\n\nclass AllType(StrType, FloatType, IntType):\n    pass\n\n\nclass Column:\n\n    def __init__(self, name):\n...\n\nclass BaseInputter:\n\n    encoding = None\n\n    def get_lines(self, table, newline=None):\n...\n    def process_lines(self, lines):\n...\n\nclass BaseSplitter:\n\n    delimiter = None\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\nclass DefaultSplitter(BaseSplitter):\n\n    delimiter = " "\n    quotechar = \'"\'\n    doublequote = True\n    escapechar = None\n    quoting = csv.QUOTE_MINIMAL\n    skipinitialspace = True\n    csv_writer = None\n    csv_writer_out = StringIO()\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\ndef _replace_tab_with_space(line, escapechar, quotechar):\n...\n\ndef _get_line_index(line_or_func, lines):\n...\n\nclass BaseHeader:\n\n    auto_format = "col{}"\n    start_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    names = None\n    write_comment = False\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n\n    def __init__(self):\n...\n    def _set_cols_from_names(self):\n...\n    def update_meta(self, lines, meta):\n...\n    def get_cols(self, lines):\n...\n    def process_lines(self, lines):\n...\n    def write_comments(self, lines, meta):\n...\n    def write(self, lines):\n...\n    @property\n    def colnames(self):\n...\n    def remove_columns(self, names):\n...\n    def rename_column(self, name, new_name):\n...\n    def get_type_map_key(self, col):\n...\n    def get_col_type(self, col):\n...\n    def check_column_names(self, names, strict_names, guessing):\n...\n\nclass BaseData:\n\n    start_line = None\n    end_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n    fill_include_names = None\n    fill_exclude_names = None\n    fill_values = [(masked, "")]\n    formats = {}\n\n    def __init__(self):\n...\n    def process_lines(self, lines):\n...\n    def get_data_lines(self, lines):\n...\n    def get_str_vals(self):\n...\n    def masks(self, cols):\n...\n    def _set_fill_values(self, cols):\n...\n    def _set_masks(self, cols):\n...\n    def _replace_vals(self, cols):\n...\n    def str_vals(self):\n...\n    def write(self, lines):\n...\n    def _set_col_formats(self):\n...\n\ndef convert_numpy(numpy_type):\n...\n\nclass BaseOutputter:\n\n    # User-defined converters which gets set in ascii.ui if a `converter` kwarg\n    # is supplied.\n    converters = {}\n\n    # Derived classes must define default_converters and __call__\n\n    @staticmethod\n    def _validate_and_copy(col, converters):\n...\n    def _convert_vals(self, cols):\n...\n\ndef _deduplicate_names(names):\n...\n\nclass TableOutputter(BaseOutputter):\n\n    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]\n\n    def __call__(self, cols, meta):\n...\n\nclass MetaBaseReader(type):\n    def __init__(cls, name, bases, dct):\n...\n\ndef _is_number(x):\n...\n\ndef _apply_include_exclude_names(table, names, include_names, exclude_names):\n...\n\nclass BaseReader(metaclass=MetaBaseReader):\n\n    names = None\n    include_names = None\n    exclude_names = None\n    strict_names = False\n    guessing = False\n    encoding = None\n\n    header_class = BaseHeader\n    data_class = BaseData\n    inputter_class = BaseInputter\n    outputter_class = TableOutputter\n\n    # Max column dimension that writer supports for this format. Exceptions\n    # include ECSV (no limit) and HTML (max_ndim=2).\n    max_ndim = 1\n\n    def __init__(self):\n...\n    def _check_multidim_table(self, table):\n...\n    def read(self, table):\n...\n    def inconsistent_handler(self, str_vals, ncols):\n...\n    @property\n    def comment_lines(self):\n...\n    def update_table_data(self, table):\n...\n    def write_header(self, lines, meta):\n...\n    def write(self, table):\n...\n\nclass ContinuationLinesInputter(BaseInputter):\n\n    continuation_char = "\\\\"\n    replace_char = " "\n    # If no_continue is not None then lines matching this regex are not subject\n    # to line continuation.  The initial use case here is Daophot.  In this\n    # case the continuation character is just replaced with replace_char.\n    no_continue = None\n\n    def process_lines(self, lines):\n...\n\nclass WhitespaceSplitter(DefaultSplitter):\n    def process_line(self, line):\n...\n\nextra_reader_pars = (\n    "Reader",\n    "Inputter",\n    "Outputter",\n    "delimiter",\n    "comment",\n    "quotechar",\n    "header_start",\n    "data_start",\n    "data_end",\n    "converters",\n    "encoding",\n    "data_Splitter",\n    "header_Splitter",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strict_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "strip_whitespace",\n    "names",\n    "include_names",\n    "exclude_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_writer(Writer, fast_writer, **kwargs):\n', 'astropy/io/ascii/ui.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_read_trace = []\n\n# Default setting for guess parameter in read()\n_GUESS = True\n\n\ndef _probably_html(table, maxchars=100000):\n...\n\ndef set_guess(guess):\n...\n\ndef get_reader(Reader=None, Inputter=None, Outputter=None, **kwargs):\n...\n\ndef _get_format_class(format, ReaderWriter, label):\n...\n\ndef _get_fast_reader_dict(kwargs):\n...\n\ndef _validate_read_write_kwargs(read_write, **kwargs):\n...\n\ndef _expand_user_if_path(argument):\n...\n\ndef read(table, guess=None, **kwargs):\n...\n\nread.__doc__ = core.READ_DOCSTRING\n\n\ndef _guess(table, read_kwargs, format, fast_reader):\n...\n\ndef _get_guess_kwargs_list(read_kwargs):\n...\n\ndef _read_in_chunks(table, **kwargs):\n...\n\ndef _read_in_chunks_generator(table, chunk_size, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strip_whitespace",\n)\n\n\ndef get_writer(Writer=None, fast_writer=True, **kwargs):\n...\n\ndef write(\n    table,\n    output=None,\n    format=None,\n    Writer=None,\n    fast_writer=True,\n    *,\n    overwrite=False,\n    **kwargs,\n):\n...\n\nwrite.__doc__ = core.WRITE_DOCSTRING\n\n\ndef get_read_trace():\n', 'astropy/io/ascii/connect.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n# This file connects the readers/writers to the astropy.table.Table class\n\n\n\n__all__ = []\n\n\ndef io_read(format, filename, **kwargs):\n...\n\ndef io_write(format, table, filename, **kwargs):\n...\n\ndef io_identify(suffix, origin, filepath, fileobj, *args, **kwargs):\n...\n\ndef _get_connectors_table():\n'}














Model found locs
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']














File Names:
['astropy/io/ascii/core.py', 'astropy/io/ascii/ui.py', 'astropy/io/ascii/connect.py']














Locs:
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']














Model Found Locs Separated:
['']














['']














['']














File Names:
['astropy/io/ascii/core.py', 'astropy/io/ascii/ui.py', 'astropy/io/ascii/connect.py']














Locs:
['path: astropy/io/ascii/core.py\nline: 1719']














Model Found Locs Separated:
['']














['']














['']














Compressed file contents:
{'astropy/modeling/separable.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n__all__ = ["is_separable", "separability_matrix"]\n\n\ndef is_separable(transform):\n...\n\ndef separability_matrix(transform):\n...\n\ndef _compute_n_outputs(left, right):\n...\n\ndef _arith_oper(left, right):\n...\n\ndef _coord_matrix(model, pos, noutp):\n...\n\ndef _cstack(left, right):\n...\n\ndef _cdot(left, right):\n...\n\ndef _separable(transform):\n...\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {\'&\': _cstack, \'|\': _cdot, \'+\': _arith_oper, \'-\': _arith_oper,\n              \'*\': _arith_oper, \'/\': _arith_oper, \'**\': _arith_oper}', 'astropy/modeling/fitting.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'LinearLSQFitter\', \'LevMarLSQFitter\', \'FittingWithOutlierRemoval\',\n           \'SLSQPLSQFitter\', \'SimplexLSQFitter\', \'JointFitter\', \'Fitter\',\n           "ModelLinearityError", "ModelsError"]\n\n\n# Statistic functions implemented in `astropy.modeling.statistic.py\nSTATISTICS = [leastsquare]\n\n# Optimizers implemented in `astropy.modeling.optimizers.py\nOPTIMIZERS = [Simplex, SLSQP]\n\n\nclass Covariance():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, params):\n...\n\nclass StandardDeviations():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def _calc_stds(self, cov_matrix):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, param):\n...\n\nclass ModelsError(Exception):\n    pass\n\n\nclass ModelLinearityError(ModelsError):\n    pass\n\n\nclass UnsupportedConstraintError(ModelsError, ValueError):\n    pass\n\n\nclass _FitterMeta(abc.ABCMeta):\n\n    registry = set()\n\n    def __new__(mcls, name, bases, members):\n...\n\ndef fitter_unit_support(func):\n...\n\nclass Fitter(metaclass=_FitterMeta):\n\n    supported_constraints = []\n\n    def __init__(self, optimizer, statistic):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(*args):\n...\n    @abc.abstractmethod\n    def __call__(self):\n...\n\n# TODO: I have ongoing branch elsewhere that\'s refactoring this module so that\n# all the fitter classes in here are Fitter subclasses.  In the meantime we\n# need to specify that _FitterMeta is its metaclass.\nclass LinearLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\']\n    supports_masked_input = True\n\n    def __init__(self, calc_uncertainties=False):\n...\n    @staticmethod\n    def _is_invertible(m):\n...\n    def _add_fitting_uncertainties(self, model, a, n_coeff, x, y, z=None,\n                                   resids=None):\n...\n    @staticmethod\n    def _deriv_with_constraints(model, param_indices, x=None, y=None):\n...\n    def _map_domain_window(self, model, x, y=None):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, rcond=None):\n...\n\nclass FittingWithOutlierRemoval:\n\n    def __init__(self, fitter, outlier_func, niter=3, **outlier_kwargs):\n...\n    def __str__(self):\n...\n    def __repr__(self):\n...\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass LevMarLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\', \'tied\', \'bounds\']\n\n    def __init__(self, calc_uncertainties=False):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(model, cov_matrix):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None,\n                 maxiter=DEFAULT_MAXITER, acc=DEFAULT_ACC,\n                 epsilon=DEFAULT_EPS, estimate_jacobian=False):\n...\n    @staticmethod\n    def _wrap_deriv(params, model, weights, x, y, z=None):\n...\n\nclass SLSQPLSQFitter(Fitter):\n\n    supported_constraints = SLSQP.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass SimplexLSQFitter(Fitter):\n\n    supported_constraints = Simplex.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass JointFitter(metaclass=_FitterMeta):\n\n    def __init__(self, models, jointparameters, initvals):\n...\n    def model_to_fit_params(self):\n...\n    def objective_function(self, fps, *args):\n...\n    def _verify_input(self):\n...\n    def __call__(self, *args):\n...\n\ndef _convert_input(x, y, z=None, n_models=1, model_set_axis=0):\n...\n\n# TODO: These utility functions are really particular to handling\n# bounds/tied/fixed constraints for scipy.optimize optimizers that do not\n# support them inherently; this needs to be reworked to be clear about this\n# distinction (and the fact that these are not necessarily applicable to any\n# arbitrary fitter--as evidenced for example by the fact that JointFitter has\n# its own versions of these)\n# TODO: Most of this code should be entirely rewritten; it should not be as\n# inefficient as it is.\ndef fitter_to_model_params(model, fps):\n...\n\n@deprecated(\'5.1\', \'private method: _fitter_to_model_params has been made public now\')\ndef _fitter_to_model_params(model, fps):\n...\n\ndef model_to_fit_params(model):\n...\n\n@deprecated(\'5.1\', \'private method: _model_to_fit_params has been made public now\')\ndef _model_to_fit_params(model):\n...\n\ndef _validate_constraints(supported_constraints, model):\n...\n\ndef _validate_model(model, supported_constraints):\n...\n\ndef populate_entry_points(entry_points):\n...\n\ndef _populate_ep():\n', 'astropy/modeling/rotations.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'RotateCelestial2Native\', \'RotateNative2Celestial\', \'Rotation2D\',\n           \'EulerAngleRotation\', \'RotationSequence3D\', \'SphericalRotationSequence\']\n\n\ndef _create_matrix(angles, axes_order):\n...\n\ndef spherical2cartesian(alpha, delta):\n...\n\ndef cartesian2spherical(x, y, z):\n...\n\nclass RotationSequence3D(Model):\n    standard_broadcasting = False\n    _separable = False\n    n_inputs = 3\n    n_outputs = 3\n\n    angles = Parameter(default=[], getter=_to_orig_unit, setter=_to_radian, description="Angles of rotation in deg in the order of axes_order")\n\n    def __init__(self, angles, axes_order, name=None):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, x, y, z, angles):\n...\n\nclass SphericalRotationSequence(RotationSequence3D):\n    def __init__(self, angles, axes_order, name=None, **kwargs):\n...\n    @property\n    def n_inputs(self):\n...\n    @property\n    def n_outputs(self):\n...\n    def evaluate(self, lon, lat, angles):\n...\n\nclass _EulerRotation:\n\n    _separable = False\n\n    def evaluate(self, alpha, delta, phi, theta, psi, axes_order):\n...\n    _input_units_strict = True\n\n    _input_units_allow_dimensionless = True\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n\nclass EulerAngleRotation(_EulerRotation, Model):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    phi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="1st Euler angle (Quantity or value in deg)")\n    theta = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="2nd Euler angle (Quantity or value in deg)")\n    psi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="3rd Euler angle (Quantity or value in deg)")\n\n    def __init__(self, phi, theta, psi, axes_order, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, alpha, delta, phi, theta, psi):\n...\n\nclass _SkyRotation(_EulerRotation, Model):\n\n    lon = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Latitude")\n    lat = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longtitude")\n    lon_pole = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longitude of a pole")\n\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def _evaluate(self, phi, theta, lon, lat, lon_pole):\n...\n\nclass RotateNative2Celestial(_SkyRotation):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, phi_N, theta_N, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass RotateCelestial2Native(_SkyRotation):\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, alpha_C, delta_C, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass Rotation2D(Model):\n    n_inputs = 2\n    n_outputs = 2\n\n    _separable = False\n\n    angle = Parameter(default=0.0, getter=_to_orig_unit, setter=_to_radian,\n    description="Angle of rotation (Quantity or value in deg)")\n\n    def __init__(self, angle=angle, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    @classmethod\n    def evaluate(cls, x, y, angle):\n...\n    @staticmethod\n    def _compute_matrix(angle):\n'}














Model found locs
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']














Results Dict (contains filenames)
{'astropy/modeling/separable.py': [], 'astropy/modeling/fitting.py': [], 'astropy/modeling/rotations.py': []}


Locs:
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']


Current Line:
path: astropy/modeling/separable.py
Current Line:
function: separability_matrix
Current Line:
function: _compute_n_outputs
Current Line:
function: _arith_oper
Current Line:
function: _coord_matrix
Current Line:
function: _cstack
Current Line:
function: _cdot
Current Line:
function: _separable
Model Found Locs Separated:
['']


['']


['']


Results Dict (contains filenames)
{'astropy/modeling/separable.py': [], 'astropy/modeling/fitting.py': [], 'astropy/modeling/rotations.py': []}


Locs:
['path: astropy/modeling/separable.py\nfunction: SeparabilityMatrix.separability_matrix\nline: 431\nline: 436']


Current Line:
path: astropy/modeling/separable.py
Current Line:
function: SeparabilityMatrix.separability_matrix
Current Line:
line: 431
Current Line:
line: 436
Model Found Locs Separated:
['']


['']


['']


Compressed file contents:
{'astropy/io/ascii/core.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Global dictionary mapping format arg to the corresponding Reader class\nFORMAT_CLASSES = {}\n\n# Similar dictionary for fast readers\nFAST_CLASSES = {}\n\n\ndef _check_multidim_table(table, max_ndim):\n...\n\nclass CsvWriter:\n\n    # Random 16-character string that gets injected instead of any\n    # empty fields and is then replaced post-write with doubled-quotechar.\n    # Created with:\n    # \'\'.join(random.choice(string.printable[:90]) for _ in range(16))\n    replace_sentinel = "2b=48Av%0-V3p>bX"\n\n    def __init__(self, csvfile=None, **kwargs):\n...\n    def writerow(self, values):\n...\n    def writerows(self, values_list):\n...\n    def _writerow(self, writerow_func, values, has_empty):\n...\n\nclass MaskedConstant(numpy.ma.core.MaskedConstant):\n\n    def __hash__(self):\n...\n    def __copy__(self):\n...\n    def __deepcopy__(self, memo):\n...\n\nmasked = MaskedConstant()\n\n\nclass InconsistentTableError(ValueError):\n    pass\n\n\nclass OptionalTableImportError(ImportError):\n    pass\n\n\nclass ParameterError(NotImplementedError):\n    pass\n\n\nclass FastOptionsError(NotImplementedError):\n    pass\n\n\nclass NoType:\n    pass\n\n\nclass StrType(NoType):\n    pass\n\n\nclass NumType(NoType):\n    pass\n\n\nclass FloatType(NumType):\n    pass\n\n\nclass BoolType(NoType):\n    pass\n\n\nclass IntType(NumType):\n    pass\n\n\nclass AllType(StrType, FloatType, IntType):\n    pass\n\n\nclass Column:\n\n    def __init__(self, name):\n...\n\nclass BaseInputter:\n\n    encoding = None\n\n    def get_lines(self, table, newline=None):\n...\n    def process_lines(self, lines):\n...\n\nclass BaseSplitter:\n\n    delimiter = None\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\nclass DefaultSplitter(BaseSplitter):\n\n    delimiter = " "\n    quotechar = \'"\'\n    doublequote = True\n    escapechar = None\n    quoting = csv.QUOTE_MINIMAL\n    skipinitialspace = True\n    csv_writer = None\n    csv_writer_out = StringIO()\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\ndef _replace_tab_with_space(line, escapechar, quotechar):\n...\n\ndef _get_line_index(line_or_func, lines):\n...\n\nclass BaseHeader:\n\n    auto_format = "col{}"\n    start_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    names = None\n    write_comment = False\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n\n    def __init__(self):\n...\n    def _set_cols_from_names(self):\n...\n    def update_meta(self, lines, meta):\n...\n    def get_cols(self, lines):\n...\n    def process_lines(self, lines):\n...\n    def write_comments(self, lines, meta):\n...\n    def write(self, lines):\n...\n    @property\n    def colnames(self):\n...\n    def remove_columns(self, names):\n...\n    def rename_column(self, name, new_name):\n...\n    def get_type_map_key(self, col):\n...\n    def get_col_type(self, col):\n...\n    def check_column_names(self, names, strict_names, guessing):\n...\n\nclass BaseData:\n\n    start_line = None\n    end_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n    fill_include_names = None\n    fill_exclude_names = None\n    fill_values = [(masked, "")]\n    formats = {}\n\n    def __init__(self):\n...\n    def process_lines(self, lines):\n...\n    def get_data_lines(self, lines):\n...\n    def get_str_vals(self):\n...\n    def masks(self, cols):\n...\n    def _set_fill_values(self, cols):\n...\n    def _set_masks(self, cols):\n...\n    def _replace_vals(self, cols):\n...\n    def str_vals(self):\n...\n    def write(self, lines):\n...\n    def _set_col_formats(self):\n...\n\ndef convert_numpy(numpy_type):\n...\n\nclass BaseOutputter:\n\n    # User-defined converters which gets set in ascii.ui if a `converter` kwarg\n    # is supplied.\n    converters = {}\n\n    # Derived classes must define default_converters and __call__\n\n    @staticmethod\n    def _validate_and_copy(col, converters):\n...\n    def _convert_vals(self, cols):\n...\n\ndef _deduplicate_names(names):\n...\n\nclass TableOutputter(BaseOutputter):\n\n    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]\n\n    def __call__(self, cols, meta):\n...\n\nclass MetaBaseReader(type):\n    def __init__(cls, name, bases, dct):\n...\n\ndef _is_number(x):\n...\n\ndef _apply_include_exclude_names(table, names, include_names, exclude_names):\n...\n\nclass BaseReader(metaclass=MetaBaseReader):\n\n    names = None\n    include_names = None\n    exclude_names = None\n    strict_names = False\n    guessing = False\n    encoding = None\n\n    header_class = BaseHeader\n    data_class = BaseData\n    inputter_class = BaseInputter\n    outputter_class = TableOutputter\n\n    # Max column dimension that writer supports for this format. Exceptions\n    # include ECSV (no limit) and HTML (max_ndim=2).\n    max_ndim = 1\n\n    def __init__(self):\n...\n    def _check_multidim_table(self, table):\n...\n    def read(self, table):\n...\n    def inconsistent_handler(self, str_vals, ncols):\n...\n    @property\n    def comment_lines(self):\n...\n    def update_table_data(self, table):\n...\n    def write_header(self, lines, meta):\n...\n    def write(self, table):\n...\n\nclass ContinuationLinesInputter(BaseInputter):\n\n    continuation_char = "\\\\"\n    replace_char = " "\n    # If no_continue is not None then lines matching this regex are not subject\n    # to line continuation.  The initial use case here is Daophot.  In this\n    # case the continuation character is just replaced with replace_char.\n    no_continue = None\n\n    def process_lines(self, lines):\n...\n\nclass WhitespaceSplitter(DefaultSplitter):\n    def process_line(self, line):\n...\n\nextra_reader_pars = (\n    "Reader",\n    "Inputter",\n    "Outputter",\n    "delimiter",\n    "comment",\n    "quotechar",\n    "header_start",\n    "data_start",\n    "data_end",\n    "converters",\n    "encoding",\n    "data_Splitter",\n    "header_Splitter",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strict_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "strip_whitespace",\n    "names",\n    "include_names",\n    "exclude_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_writer(Writer, fast_writer, **kwargs):\n', 'astropy/io/ascii/ui.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_read_trace = []\n\n# Default setting for guess parameter in read()\n_GUESS = True\n\n\ndef _probably_html(table, maxchars=100000):\n...\n\ndef set_guess(guess):\n...\n\ndef get_reader(Reader=None, Inputter=None, Outputter=None, **kwargs):\n...\n\ndef _get_format_class(format, ReaderWriter, label):\n...\n\ndef _get_fast_reader_dict(kwargs):\n...\n\ndef _validate_read_write_kwargs(read_write, **kwargs):\n...\n\ndef _expand_user_if_path(argument):\n...\n\ndef read(table, guess=None, **kwargs):\n...\n\nread.__doc__ = core.READ_DOCSTRING\n\n\ndef _guess(table, read_kwargs, format, fast_reader):\n...\n\ndef _get_guess_kwargs_list(read_kwargs):\n...\n\ndef _read_in_chunks(table, **kwargs):\n...\n\ndef _read_in_chunks_generator(table, chunk_size, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strip_whitespace",\n)\n\n\ndef get_writer(Writer=None, fast_writer=True, **kwargs):\n...\n\ndef write(\n    table,\n    output=None,\n    format=None,\n    Writer=None,\n    fast_writer=True,\n    *,\n    overwrite=False,\n    **kwargs,\n):\n...\n\nwrite.__doc__ = core.WRITE_DOCSTRING\n\n\ndef get_read_trace():\n', 'astropy/io/ascii/connect.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n# This file connects the readers/writers to the astropy.table.Table class\n\n\n\n__all__ = []\n\n\ndef io_read(format, filename, **kwargs):\n...\n\ndef io_write(format, table, filename, **kwargs):\n...\n\ndef io_identify(suffix, origin, filepath, fileobj, *args, **kwargs):\n...\n\ndef _get_connectors_table():\n'}














Model found locs
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']














Results Dict (contains filenames)
{'astropy/io/ascii/core.py': [], 'astropy/io/ascii/ui.py': [], 'astropy/io/ascii/connect.py': []}


Locs:
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']


Current Line:
path: astropy/io/ascii/core.py
Current Line:
function: _get_writer
Current Line:
class: RST
Model Found Locs Separated:
['']


['']


['']


Results Dict (contains filenames)
{'astropy/io/ascii/core.py': [], 'astropy/io/ascii/ui.py': [], 'astropy/io/ascii/connect.py': []}


Locs:
['path: astropy/io/ascii/core.py\nclass: RST']


Current Line:
path: astropy/io/ascii/core.py
Current Line:
class: RST
Model Found Locs Separated:
['']


['']


['']


Compressed file contents:
{'astropy/io/ascii/qdp.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\ndef _line_type(line, delimiter=None):\n...\n\ndef _get_type_from_list_of_lines(lines, delimiter=None):\n...\n\ndef _get_lines_from_file(qdp_file):\n...\n\ndef _interpret_err_lines(err_specs, ncols, names=None):\n...\n\ndef _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n...\n\ndef _understand_err_col(colnames):\n...\n\ndef _read_table_qdp(qdp_file, names=None, table_id=None, delimiter=None):\n...\n\ndef _write_table_qdp(table, filename=None, err_specs=None):\n...\n\nclass QDPSplitter(core.DefaultSplitter):\n\n    delimiter = " "\n\n\nclass QDPHeader(basic.CommentedHeaderHeader):\n\n    splitter_class = QDPSplitter\n    comment = "!"\n    write_comment = "!"\n\n\nclass QDPData(basic.BasicData):\n\n    splitter_class = QDPSplitter\n    fill_values = [(core.masked, "NO")]\n    comment = "!"\n    write_comment = None\n\n\nclass QDP(basic.Basic):\n\n    _format_name = "qdp"\n    _io_registry_can_write = True\n    _io_registry_suffix = ".qdp"\n    _description = "Quick and Dandy Plotter"\n\n    header_class = QDPHeader\n    data_class = QDPData\n\n    def __init__(self, table_id=None, names=None, err_specs=None, sep=None):\n...\n    def read(self, table):\n...\n    def write(self, table):\n', 'astropy/table/table.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_implementation_notes = """\nThis string has informal notes concerning Table implementation for developers.\n\nThings to remember:\n\n- Table has customizable attributes ColumnClass, Column, MaskedColumn.\n  Table.Column is normally just column.Column (same w/ MaskedColumn)\n  but in theory they can be different.  Table.ColumnClass is the default\n  class used to create new non-mixin columns, and this is a function of\n  the Table.masked attribute.  Column creation / manipulation in a Table\n  needs to respect these.\n\n- Column objects that get inserted into the Table.columns attribute must\n  have the info.parent_table attribute set correctly.  Beware just dropping\n  an object into the columns dict since an existing column may\n  be part of another Table and have parent_table set to point at that\n  table.  Dropping that column into `columns` of this Table will cause\n  a problem for the old one so the column object needs to be copied (but\n  not necessarily the data).\n\n  Currently replace_column is always making a copy of both object and\n  data if parent_table is set.  This could be improved but requires a\n  generic way to copy a mixin object but not the data.\n\n- Be aware of column objects that have indices set.\n\n- `cls.ColumnClass` is a property that effectively uses the `masked` attribute\n  to choose either `cls.Column` or `cls.MaskedColumn`.\n"""\n\n__doctest_skip__ = [\n    "Table.read",\n    "Table.write",\n    "Table._read",\n    "Table.convert_bytestring_to_unicode",\n    "Table.convert_unicode_to_bytestring",\n]\n\n__doctest_requires__ = {"*pandas": ["pandas>=1.1"]}\n\n_pprint_docs = """\n    {__doc__}\n\n    Parameters\n    ----------\n    max_lines : int or None\n        Maximum number of lines in table output.\n\n    max_width : int or None\n        Maximum character width of output.\n\n    show_name : bool\n        Include a header row for column names. Default is True.\n\n    show_unit : bool\n        Include a header row for unit.  Default is to show a row\n        for units only if one or more columns has a defined value\n        for the unit.\n\n    show_dtype : bool\n        Include a header row for column dtypes. Default is False.\n\n    align : str or list or tuple or None\n        Left/right alignment of columns. Default is right (None) for all\n        columns. Other allowed values are \'>\', \'<\', \'^\', and \'0=\' for\n        right, left, centered, and 0-padded, respectively. A list of\n        strings can be provided for alignment of tables with multiple\n        columns.\n    """\n\n_pformat_docs = """\n    {__doc__}\n\n    Parameters\n    ----------\n    max_lines : int or None\n        Maximum number of rows to output\n\n    max_width : int or None\n        Maximum character width of output\n\n    show_name : bool\n        Include a header row for column names. Default is True.\n\n    show_unit : bool\n        Include a header row for unit.  Default is to show a row\n        for units only if one or more columns has a defined value\n        for the unit.\n\n    show_dtype : bool\n        Include a header row for column dtypes. Default is True.\n\n    html : bool\n        Format the output as an HTML table. Default is False.\n\n    tableid : str or None\n        An ID tag for the table; only used if html is set.  Default is\n        "table{id}", where id is the unique integer id of the table object,\n        id(self)\n\n    align : str or list or tuple or None\n        Left/right alignment of columns. Default is right (None) for all\n        columns. Other allowed values are \'>\', \'<\', \'^\', and \'0=\' for\n        right, left, centered, and 0-padded, respectively. A list of\n        strings can be provided for alignment of tables with multiple\n        columns.\n\n    tableclass : str or list of str or None\n        CSS classes for the table; only used if html is set.  Default is\n        None.\n\n    Returns\n    -------\n    lines : list\n        Formatted table as a list of strings.\n    """\n\n\nclass TableReplaceWarning(UserWarning):\n\n    pass\n\n\ndef descr(col):\n...\n\ndef has_info_class(obj, cls):\n...\n\ndef _get_names_from_list_of_dict(rows):\n...\n\n# Note to future maintainers: when transitioning this to dict\n# be sure to change the OrderedDict ref(s) in Row and in __len__().\n\n\nclass TableColumns(OrderedDict):\n\n    def __init__(self, cols={}):\n...\n    def __getitem__(self, item):\n...\n    def __setitem__(self, item, value, validated=False):\n...\n    def __repr__(self):\n...\n    def _rename_column(self, name, new_name):\n...\n    def __delitem__(self, name):\n...\n    def isinstance(self, cls):\n...\n    def not_isinstance(self, cls):\n...\n\nclass TableAttribute(MetaAttribute):\n    pass\n\n\nclass PprintIncludeExclude(TableAttribute):\n\n    def __get__(self, instance, owner_cls):\n...\n    def __set__(self, instance, names):\n...\n    def __call__(self):\n...\n    def __repr__(self):\n...\n    def _add_remove_setup(self, names):\n...\n    def add(self, names):\n...\n    def remove(self, names):\n...\n    def _remove(self, names, raise_exc=False):\n...\n    def _rename(self, name, new_name):\n...\n    def set(self, names):\n...\n\nclass Table:\n\n    meta = MetaData(copy=False)\n\n    # Define class attributes for core container objects to allow for subclass\n    # customization.\n    Row = Row\n    Column = Column\n    MaskedColumn = MaskedColumn\n    TableColumns = TableColumns\n    TableFormatter = TableFormatter\n\n    # Unified I/O read and write methods from .connect\n    read = UnifiedReadWriteMethod(TableRead)\n    write = UnifiedReadWriteMethod(TableWrite)\n\n    pprint_exclude_names = PprintIncludeExclude()\n    pprint_include_names = PprintIncludeExclude()\n\n    def as_array(self, keep_byteorder=False, names=None):\n...\n    def __init__(\n        self,\n        data=None,\n        masked=False,\n        names=None,\n        dtype=None,\n        meta=None,\n        copy=True,\n        rows=None,\n        copy_indices=True,\n        units=None,\n        descriptions=None,\n        **kwargs,\n    ):\n...\n    def _set_column_attribute(self, attr, values):\n...\n    def __getstate__(self):\n...\n    def __setstate__(self, state):\n...\n    @property\n    def mask(self):\n...\n    @mask.setter\n    def mask(self, val):\n...\n    @property\n    def _mask(self):\n...\n    def filled(self, fill_value=None):\n...\n    @property\n    def indices(self):\n...\n    @property\n    def loc(self):\n...\n    @property\n    def loc_indices(self):\n...\n    @property\n    def iloc(self):\n...\n    def add_index(self, colnames, engine=None, unique=False):\n...\n    def remove_indices(self, colname):\n...\n    def index_mode(self, mode):\n...\n    def __array__(self, dtype=None):\n...\n    def _check_names_dtype(self, names, dtype, n_cols):\n...\n    def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):\n...\n    def _init_from_list(self, data, names, dtype, n_cols, copy):\n...\n    def _convert_data_to_col(\n        self, data, copy=True, default_name=None, dtype=None, name=None\n    ):\n...\n    def _init_from_ndarray(self, data, names, dtype, n_cols, copy):\n...\n    def _init_from_dict(self, data, names, dtype, n_cols, copy):\n...\n    def _get_col_cls_for_table(self, col):\n...\n    def _convert_col_for_table(self, col):\n...\n    def _init_from_cols(self, cols):\n...\n    def _new_from_slice(self, slice_):\n...\n    @staticmethod\n    def _make_table_from_cols(table, cols, verify=True, names=None):\n...\n    def _set_col_parent_table_and_mask(self, col):\n...\n    def itercols(self):\n...\n    def _base_repr_(\n        self,\n        html=False,\n        descr_vals=None,\n        max_width=None,\n        tableid=None,\n        show_dtype=True,\n        max_lines=None,\n        tableclass=None,\n    ):\n...\n    def _repr_html_(self):\n...\n    def __repr__(self):\n...\n    def __str__(self):\n...\n    def __bytes__(self):\n...\n    @property\n    def has_mixin_columns(self):\n...\n    @property\n    def has_masked_columns(self):\n...\n    @property\n    def has_masked_values(self):\n...\n    def _is_mixin_for_table(self, col):\n...\n    @format_doc(_pprint_docs)\n    def pprint(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        align=None,\n    ):\n...\n    @format_doc(_pprint_docs)\n    def pprint_all(\n        self,\n        max_lines=-1,\n        max_width=-1,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        align=None,\n    ):\n...\n    def _make_index_row_display_table(self, index_row_name):\n...\n    def show_in_notebook(\n        self,\n        tableid=None,\n        css=None,\n        display_length=50,\n        table_class="astropy-default",\n        show_row_index="idx",\n    ):\n...\n    def show_in_browser(\n        self,\n        max_lines=5000,\n        jsviewer=False,\n        browser="default",\n        jskwargs={"use_local_files": True},\n        tableid=None,\n        table_class="display compact",\n        css=None,\n        show_row_index="idx",\n    ):\n...\n    @format_doc(_pformat_docs, id="{id}")\n    def pformat(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        html=False,\n        tableid=None,\n        align=None,\n        tableclass=None,\n    ):\n...\n    @format_doc(_pformat_docs, id="{id}")\n    def pformat_all(\n        self,\n        max_lines=-1,\n        max_width=-1,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        html=False,\n        tableid=None,\n        align=None,\n        tableclass=None,\n    ):\n...\n    def more(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n    ):\n...\n    def __getitem__(self, item):\n...\n    def __setitem__(self, item, value):\n...\n    def __delitem__(self, item):\n...\n    def _ipython_key_completions_(self):\n...\n    def field(self, item):\n...\n    @property\n    def masked(self):\n...\n    @masked.setter\n    def masked(self, masked):\n...\n    def _set_masked(self, masked):\n...\n    @property\n    def ColumnClass(self):\n...\n    @property\n    def dtype(self):\n...\n    @property\n    def colnames(self):\n...\n    @staticmethod\n    def _is_list_or_tuple_of_str(names):\n...\n    def keys(self):\n...\n    def values(self):\n...\n    def items(self):\n...\n    def __len__(self):\n...\n    def __or__(self, other):\n...\n    def __ior__(self, other):\n...\n    def index_column(self, name):\n...\n    def add_column(\n        self,\n        col,\n        index=None,\n        name=None,\n        rename_duplicate=False,\n        copy=True,\n        default_name=None,\n    ):\n...\n    def add_columns(\n        self, cols, indexes=None, names=None, copy=True, rename_duplicate=False\n    ):\n...\n    def _replace_column_warnings(self, name, col):\n...\n    def replace_column(self, name, col, copy=True):\n...\n    def remove_row(self, index):\n...\n    def remove_rows(self, row_specifier):\n...\n    def iterrows(self, *names):\n...\n    def _set_of_names_in_colnames(self, names):\n...\n    def remove_column(self, name):\n...\n    def remove_columns(self, names):\n...\n    def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):\n...\n    def convert_bytestring_to_unicode(self):\n...\n    def convert_unicode_to_bytestring(self):\n...\n    def keep_columns(self, names):\n...\n    def rename_column(self, name, new_name):\n...\n    def rename_columns(self, names, new_names):\n...\n    def _set_row(self, idx, colnames, vals):\n...\n    def add_row(self, vals=None, mask=None):\n...\n    def insert_row(self, index, vals=None, mask=None):\n...\n    def _replace_cols(self, columns):\n...\n    def update(self, other, copy=True):\n...\n    def argsort(self, keys=None, kind=None, reverse=False):\n...\n    def sort(self, keys=None, *, kind=None, reverse=False):\n...\n    def reverse(self):\n...\n    def round(self, decimals=0):\n...\n    def copy(self, copy_data=True):\n...\n    def __deepcopy__(self, memo=None):\n...\n    def __copy__(self):\n...\n    def __lt__(self, other):\n...\n    def __gt__(self, other):\n...\n    def __le__(self, other):\n...\n    def __ge__(self, other):\n...\n    def __eq__(self, other):\n...\n    def __ne__(self, other):\n...\n    def _rows_equal(self, other):\n...\n    def values_equal(self, other):\n...\n    @property\n    def groups(self):\n...\n    def group_by(self, keys):\n...\n    def to_pandas(self, index=None, use_nullable_int=True):\n...\n    @classmethod\n    def from_pandas(cls, dataframe, index=False, units=None):\n...\n    info = TableInfo()\n\n\nclass QTable(Table):\n\n    def _is_mixin_for_table(self, col):\n...\n    def _convert_col_for_table(self, col):\n'}














Model found locs
['path: astropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP']














Results Dict (contains filenames)
{'astropy/io/ascii/qdp.py': [], 'astropy/table/table.py': []}


Locs:
['path: astropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP']


Current Line:
path: astropy/io/ascii/qdp.py
Current Line:
function: _line_type
Current Line:
function: _get_type_from_list_of_lines
Current Line:
function: _get_lines_from_file
Current Line:
function: _interpret_err_lines
Current Line:
function: _get_tables_from_qdp_file
Current Line:
function: _understand_err_col
Current Line:
function: _read_table_qdp
Current Line:
function: _write_table_qdp
Current Line:
class: QDPSplitter
Current Line:
class: QDPHeader
Current Line:
class: QDPData
Current Line:
class: QDP
Model Found Locs Separated:
['']


['']


Results Dict (contains filenames)
{'astropy/io/ascii/qdp.py': [], 'astropy/table/table.py': []}


Locs:
['path: astropy/table/ascii.py\nline: 897\nfunction: _read']


Current Line:
path: astropy/table/ascii.py
Current Line:
line: 897
Current Line:
function: _read
Model Found Locs Separated:
['']


['']


Results Dict (contains filenames)
{}


Locs:
['path: astropy/nddata/nddata.py\nfunction: NDDataRef.multiply\nline: 543']


Current Line:
path: astropy/nddata/nddata.py
Current Line:
function: NDDataRef.multiply
Current Line:
line: 543
Model Found Locs Separated:
Compressed file contents:
{'astropy/modeling/separable.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n\n__all__ = ["is_separable", "separability_matrix"]\n\n\ndef is_separable(transform):\n...\n\ndef separability_matrix(transform):\n...\n\ndef _compute_n_outputs(left, right):\n...\n\ndef _arith_oper(left, right):\n...\n\ndef _coord_matrix(model, pos, noutp):\n...\n\ndef _cstack(left, right):\n...\n\ndef _cdot(left, right):\n...\n\ndef _separable(transform):\n...\n\n# Maps modeling operators to a function computing and represents the\n# relationship of axes as an array of 0-es and 1-s\n_operators = {\'&\': _cstack, \'|\': _cdot, \'+\': _arith_oper, \'-\': _arith_oper,\n              \'*\': _arith_oper, \'/\': _arith_oper, \'**\': _arith_oper}', 'astropy/modeling/fitting.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'LinearLSQFitter\', \'LevMarLSQFitter\', \'FittingWithOutlierRemoval\',\n           \'SLSQPLSQFitter\', \'SimplexLSQFitter\', \'JointFitter\', \'Fitter\',\n           "ModelLinearityError", "ModelsError"]\n\n\n# Statistic functions implemented in `astropy.modeling.statistic.py\nSTATISTICS = [leastsquare]\n\n# Optimizers implemented in `astropy.modeling.optimizers.py\nOPTIMIZERS = [Simplex, SLSQP]\n\n\nclass Covariance():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, params):\n...\n\nclass StandardDeviations():\n\n    def __init__(self, cov_matrix, param_names):\n...\n    def _calc_stds(self, cov_matrix):\n...\n    def pprint(self, max_lines, round_val):\n...\n    def __repr__(self):\n...\n    def __getitem__(self, param):\n...\n\nclass ModelsError(Exception):\n    pass\n\n\nclass ModelLinearityError(ModelsError):\n    pass\n\n\nclass UnsupportedConstraintError(ModelsError, ValueError):\n    pass\n\n\nclass _FitterMeta(abc.ABCMeta):\n\n    registry = set()\n\n    def __new__(mcls, name, bases, members):\n...\n\ndef fitter_unit_support(func):\n...\n\nclass Fitter(metaclass=_FitterMeta):\n\n    supported_constraints = []\n\n    def __init__(self, optimizer, statistic):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(*args):\n...\n    @abc.abstractmethod\n    def __call__(self):\n...\n\n# TODO: I have ongoing branch elsewhere that\'s refactoring this module so that\n# all the fitter classes in here are Fitter subclasses.  In the meantime we\n# need to specify that _FitterMeta is its metaclass.\nclass LinearLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\']\n    supports_masked_input = True\n\n    def __init__(self, calc_uncertainties=False):\n...\n    @staticmethod\n    def _is_invertible(m):\n...\n    def _add_fitting_uncertainties(self, model, a, n_coeff, x, y, z=None,\n                                   resids=None):\n...\n    @staticmethod\n    def _deriv_with_constraints(model, param_indices, x=None, y=None):\n...\n    def _map_domain_window(self, model, x, y=None):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, rcond=None):\n...\n\nclass FittingWithOutlierRemoval:\n\n    def __init__(self, fitter, outlier_func, niter=3, **outlier_kwargs):\n...\n    def __str__(self):\n...\n    def __repr__(self):\n...\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass LevMarLSQFitter(metaclass=_FitterMeta):\n\n    supported_constraints = [\'fixed\', \'tied\', \'bounds\']\n\n    def __init__(self, calc_uncertainties=False):\n...\n    def objective_function(self, fps, *args):\n...\n    @staticmethod\n    def _add_fitting_uncertainties(model, cov_matrix):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None,\n                 maxiter=DEFAULT_MAXITER, acc=DEFAULT_ACC,\n                 epsilon=DEFAULT_EPS, estimate_jacobian=False):\n...\n    @staticmethod\n    def _wrap_deriv(params, model, weights, x, y, z=None):\n...\n\nclass SLSQPLSQFitter(Fitter):\n\n    supported_constraints = SLSQP.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass SimplexLSQFitter(Fitter):\n\n    supported_constraints = Simplex.supported_constraints\n\n    def __init__(self):\n...\n    @fitter_unit_support\n    def __call__(self, model, x, y, z=None, weights=None, **kwargs):\n...\n\nclass JointFitter(metaclass=_FitterMeta):\n\n    def __init__(self, models, jointparameters, initvals):\n...\n    def model_to_fit_params(self):\n...\n    def objective_function(self, fps, *args):\n...\n    def _verify_input(self):\n...\n    def __call__(self, *args):\n...\n\ndef _convert_input(x, y, z=None, n_models=1, model_set_axis=0):\n...\n\n# TODO: These utility functions are really particular to handling\n# bounds/tied/fixed constraints for scipy.optimize optimizers that do not\n# support them inherently; this needs to be reworked to be clear about this\n# distinction (and the fact that these are not necessarily applicable to any\n# arbitrary fitter--as evidenced for example by the fact that JointFitter has\n# its own versions of these)\n# TODO: Most of this code should be entirely rewritten; it should not be as\n# inefficient as it is.\ndef fitter_to_model_params(model, fps):\n...\n\n@deprecated(\'5.1\', \'private method: _fitter_to_model_params has been made public now\')\ndef _fitter_to_model_params(model, fps):\n...\n\ndef model_to_fit_params(model):\n...\n\n@deprecated(\'5.1\', \'private method: _model_to_fit_params has been made public now\')\ndef _model_to_fit_params(model):\n...\n\ndef _validate_constraints(supported_constraints, model):\n...\n\ndef _validate_model(model, supported_constraints):\n...\n\ndef populate_entry_points(entry_points):\n...\n\ndef _populate_ep():\n', 'astropy/modeling/rotations.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = [\'RotateCelestial2Native\', \'RotateNative2Celestial\', \'Rotation2D\',\n           \'EulerAngleRotation\', \'RotationSequence3D\', \'SphericalRotationSequence\']\n\n\ndef _create_matrix(angles, axes_order):\n...\n\ndef spherical2cartesian(alpha, delta):\n...\n\ndef cartesian2spherical(x, y, z):\n...\n\nclass RotationSequence3D(Model):\n    standard_broadcasting = False\n    _separable = False\n    n_inputs = 3\n    n_outputs = 3\n\n    angles = Parameter(default=[], getter=_to_orig_unit, setter=_to_radian, description="Angles of rotation in deg in the order of axes_order")\n\n    def __init__(self, angles, axes_order, name=None):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, x, y, z, angles):\n...\n\nclass SphericalRotationSequence(RotationSequence3D):\n    def __init__(self, angles, axes_order, name=None, **kwargs):\n...\n    @property\n    def n_inputs(self):\n...\n    @property\n    def n_outputs(self):\n...\n    def evaluate(self, lon, lat, angles):\n...\n\nclass _EulerRotation:\n\n    _separable = False\n\n    def evaluate(self, alpha, delta, phi, theta, psi, axes_order):\n...\n    _input_units_strict = True\n\n    _input_units_allow_dimensionless = True\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n\nclass EulerAngleRotation(_EulerRotation, Model):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    phi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="1st Euler angle (Quantity or value in deg)")\n    theta = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="2nd Euler angle (Quantity or value in deg)")\n    psi = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian,\n    description="3rd Euler angle (Quantity or value in deg)")\n\n    def __init__(self, phi, theta, psi, axes_order, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    def evaluate(self, alpha, delta, phi, theta, psi):\n...\n\nclass _SkyRotation(_EulerRotation, Model):\n\n    lon = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Latitude")\n    lat = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longtitude")\n    lon_pole = Parameter(default=0, getter=_to_orig_unit, setter=_to_radian, description="Longitude of a pole")\n\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def _evaluate(self, phi, theta, lon, lat, lon_pole):\n...\n\nclass RotateNative2Celestial(_SkyRotation):\n\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, phi_N, theta_N, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass RotateCelestial2Native(_SkyRotation):\n    n_inputs = 2\n    n_outputs = 2\n\n    @property\n    def input_units(self):\n...\n    @property\n    def return_units(self):\n...\n    def __init__(self, lon, lat, lon_pole, **kwargs):\n...\n    def evaluate(self, alpha_C, delta_C, lon, lat, lon_pole):\n...\n    @property\n    def inverse(self):\n...\n\nclass Rotation2D(Model):\n    n_inputs = 2\n    n_outputs = 2\n\n    _separable = False\n\n    angle = Parameter(default=0.0, getter=_to_orig_unit, setter=_to_radian,\n    description="Angle of rotation (Quantity or value in deg)")\n\n    def __init__(self, angle=angle, **kwargs):\n...\n    @property\n    def inverse(self):\n...\n    @classmethod\n    def evaluate(cls, x, y, angle):\n...\n    @staticmethod\n    def _compute_matrix(angle):\n'}














Model found locs
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']














Results Dict (contains filenames)
{'astropy/modeling/separable.py': [], 'astropy/modeling/fitting.py': [], 'astropy/modeling/rotations.py': []}


Locs:
['path: astropy/modeling/separable.py\nfunction: separability_matrix\nfunction: _compute_n_outputs\nfunction: _arith_oper\nfunction: _coord_matrix\nfunction: _cstack\nfunction: _cdot\nfunction: _separable']


Current Line:
path: astropy/modeling/separable.py
Current Line:
function: separability_matrix
Current Line:
function: _compute_n_outputs
Current Line:
function: _arith_oper
Current Line:
function: _coord_matrix
Current Line:
function: _cstack
Current Line:
function: _cdot
Current Line:
function: _separable
Model Found Locs Separated:
['']


['']


['']


Results Dict (contains filenames)
{'astropy/modeling/separable.py': [], 'astropy/modeling/fitting.py': [], 'astropy/modeling/rotations.py': []}


Locs:
['path: astropy/modeling/separable.py\nline: 437']


Current Line:
path: astropy/modeling/separable.py
Current Line:
line: 437
Model Found Locs Separated:
['']


['']


['']


Compressed file contents:
{'astropy/io/ascii/core.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Global dictionary mapping format arg to the corresponding Reader class\nFORMAT_CLASSES = {}\n\n# Similar dictionary for fast readers\nFAST_CLASSES = {}\n\n\ndef _check_multidim_table(table, max_ndim):\n...\n\nclass CsvWriter:\n\n    # Random 16-character string that gets injected instead of any\n    # empty fields and is then replaced post-write with doubled-quotechar.\n    # Created with:\n    # \'\'.join(random.choice(string.printable[:90]) for _ in range(16))\n    replace_sentinel = "2b=48Av%0-V3p>bX"\n\n    def __init__(self, csvfile=None, **kwargs):\n...\n    def writerow(self, values):\n...\n    def writerows(self, values_list):\n...\n    def _writerow(self, writerow_func, values, has_empty):\n...\n\nclass MaskedConstant(numpy.ma.core.MaskedConstant):\n\n    def __hash__(self):\n...\n    def __copy__(self):\n...\n    def __deepcopy__(self, memo):\n...\n\nmasked = MaskedConstant()\n\n\nclass InconsistentTableError(ValueError):\n    pass\n\n\nclass OptionalTableImportError(ImportError):\n    pass\n\n\nclass ParameterError(NotImplementedError):\n    pass\n\n\nclass FastOptionsError(NotImplementedError):\n    pass\n\n\nclass NoType:\n    pass\n\n\nclass StrType(NoType):\n    pass\n\n\nclass NumType(NoType):\n    pass\n\n\nclass FloatType(NumType):\n    pass\n\n\nclass BoolType(NoType):\n    pass\n\n\nclass IntType(NumType):\n    pass\n\n\nclass AllType(StrType, FloatType, IntType):\n    pass\n\n\nclass Column:\n\n    def __init__(self, name):\n...\n\nclass BaseInputter:\n\n    encoding = None\n\n    def get_lines(self, table, newline=None):\n...\n    def process_lines(self, lines):\n...\n\nclass BaseSplitter:\n\n    delimiter = None\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\nclass DefaultSplitter(BaseSplitter):\n\n    delimiter = " "\n    quotechar = \'"\'\n    doublequote = True\n    escapechar = None\n    quoting = csv.QUOTE_MINIMAL\n    skipinitialspace = True\n    csv_writer = None\n    csv_writer_out = StringIO()\n\n    def process_line(self, line):\n...\n    def process_val(self, val):\n...\n    def __call__(self, lines):\n...\n    def join(self, vals):\n...\n\ndef _replace_tab_with_space(line, escapechar, quotechar):\n...\n\ndef _get_line_index(line_or_func, lines):\n...\n\nclass BaseHeader:\n\n    auto_format = "col{}"\n    start_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    names = None\n    write_comment = False\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n\n    def __init__(self):\n...\n    def _set_cols_from_names(self):\n...\n    def update_meta(self, lines, meta):\n...\n    def get_cols(self, lines):\n...\n    def process_lines(self, lines):\n...\n    def write_comments(self, lines, meta):\n...\n    def write(self, lines):\n...\n    @property\n    def colnames(self):\n...\n    def remove_columns(self, names):\n...\n    def rename_column(self, name, new_name):\n...\n    def get_type_map_key(self, col):\n...\n    def get_col_type(self, col):\n...\n    def check_column_names(self, names, strict_names, guessing):\n...\n\nclass BaseData:\n\n    start_line = None\n    end_line = None\n    comment = None\n    splitter_class = DefaultSplitter\n    write_spacer_lines = ["ASCII_TABLE_WRITE_SPACER_LINE"]\n    fill_include_names = None\n    fill_exclude_names = None\n    fill_values = [(masked, "")]\n    formats = {}\n\n    def __init__(self):\n...\n    def process_lines(self, lines):\n...\n    def get_data_lines(self, lines):\n...\n    def get_str_vals(self):\n...\n    def masks(self, cols):\n...\n    def _set_fill_values(self, cols):\n...\n    def _set_masks(self, cols):\n...\n    def _replace_vals(self, cols):\n...\n    def str_vals(self):\n...\n    def write(self, lines):\n...\n    def _set_col_formats(self):\n...\n\ndef convert_numpy(numpy_type):\n...\n\nclass BaseOutputter:\n\n    # User-defined converters which gets set in ascii.ui if a `converter` kwarg\n    # is supplied.\n    converters = {}\n\n    # Derived classes must define default_converters and __call__\n\n    @staticmethod\n    def _validate_and_copy(col, converters):\n...\n    def _convert_vals(self, cols):\n...\n\ndef _deduplicate_names(names):\n...\n\nclass TableOutputter(BaseOutputter):\n\n    default_converters = [convert_numpy(int), convert_numpy(float), convert_numpy(str)]\n\n    def __call__(self, cols, meta):\n...\n\nclass MetaBaseReader(type):\n    def __init__(cls, name, bases, dct):\n...\n\ndef _is_number(x):\n...\n\ndef _apply_include_exclude_names(table, names, include_names, exclude_names):\n...\n\nclass BaseReader(metaclass=MetaBaseReader):\n\n    names = None\n    include_names = None\n    exclude_names = None\n    strict_names = False\n    guessing = False\n    encoding = None\n\n    header_class = BaseHeader\n    data_class = BaseData\n    inputter_class = BaseInputter\n    outputter_class = TableOutputter\n\n    # Max column dimension that writer supports for this format. Exceptions\n    # include ECSV (no limit) and HTML (max_ndim=2).\n    max_ndim = 1\n\n    def __init__(self):\n...\n    def _check_multidim_table(self, table):\n...\n    def read(self, table):\n...\n    def inconsistent_handler(self, str_vals, ncols):\n...\n    @property\n    def comment_lines(self):\n...\n    def update_table_data(self, table):\n...\n    def write_header(self, lines, meta):\n...\n    def write(self, table):\n...\n\nclass ContinuationLinesInputter(BaseInputter):\n\n    continuation_char = "\\\\"\n    replace_char = " "\n    # If no_continue is not None then lines matching this regex are not subject\n    # to line continuation.  The initial use case here is Daophot.  In this\n    # case the continuation character is just replaced with replace_char.\n    no_continue = None\n\n    def process_lines(self, lines):\n...\n\nclass WhitespaceSplitter(DefaultSplitter):\n    def process_line(self, line):\n...\n\nextra_reader_pars = (\n    "Reader",\n    "Inputter",\n    "Outputter",\n    "delimiter",\n    "comment",\n    "quotechar",\n    "header_start",\n    "data_start",\n    "data_end",\n    "converters",\n    "encoding",\n    "data_Splitter",\n    "header_Splitter",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strict_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_reader(Reader, Inputter=None, Outputter=None, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "strip_whitespace",\n    "names",\n    "include_names",\n    "exclude_names",\n    "fill_values",\n    "fill_include_names",\n    "fill_exclude_names",\n)\n\n\ndef _get_writer(Writer, fast_writer, **kwargs):\n', 'astropy/table/connect.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\n__all__ = ["TableRead", "TableWrite"]\n__doctest_skip__ = ["TableRead", "TableWrite"]\n\n\nclass TableRead(registry.UnifiedReadWrite):\n\n    def __init__(self, instance, cls):\n...\n    def __call__(self, *args, **kwargs):\n...\n\nclass TableWrite(registry.UnifiedReadWrite):\n\n    def __init__(self, instance, cls):\n...\n    def __call__(self, *args, serialize_method=None, **kwargs):\n', 'astropy/io/ascii/ui.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_read_trace = []\n\n# Default setting for guess parameter in read()\n_GUESS = True\n\n\ndef _probably_html(table, maxchars=100000):\n...\n\ndef set_guess(guess):\n...\n\ndef get_reader(Reader=None, Inputter=None, Outputter=None, **kwargs):\n...\n\ndef _get_format_class(format, ReaderWriter, label):\n...\n\ndef _get_fast_reader_dict(kwargs):\n...\n\ndef _validate_read_write_kwargs(read_write, **kwargs):\n...\n\ndef _expand_user_if_path(argument):\n...\n\ndef read(table, guess=None, **kwargs):\n...\n\nread.__doc__ = core.READ_DOCSTRING\n\n\ndef _guess(table, read_kwargs, format, fast_reader):\n...\n\ndef _get_guess_kwargs_list(read_kwargs):\n...\n\ndef _read_in_chunks(table, **kwargs):\n...\n\ndef _read_in_chunks_generator(table, chunk_size, **kwargs):\n...\n\nextra_writer_pars = (\n    "delimiter",\n    "comment",\n    "quotechar",\n    "formats",\n    "names",\n    "include_names",\n    "exclude_names",\n    "strip_whitespace",\n)\n\n\ndef get_writer(Writer=None, fast_writer=True, **kwargs):\n...\n\ndef write(\n    table,\n    output=None,\n    format=None,\n    Writer=None,\n    fast_writer=True,\n    *,\n    overwrite=False,\n    **kwargs,\n):\n...\n\nwrite.__doc__ = core.WRITE_DOCSTRING\n\n\ndef get_read_trace():\n'}














Model found locs
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']














Results Dict (contains filenames)
{'astropy/io/ascii/core.py': [], 'astropy/table/connect.py': [], 'astropy/io/ascii/ui.py': []}


Locs:
['path: astropy/io/ascii/core.py\nfunction: _get_writer\nclass: RST']


Current Line:
path: astropy/io/ascii/core.py
Current Line:
function: _get_writer
Current Line:
class: RST
Model Found Locs Separated:
['']


['']


['']


Results Dict (contains filenames)
{'astropy/io/ascii/core.py': [], 'astropy/table/connect.py': [], 'astropy/io/ascii/ui.py': []}


Locs:
['path: astropy/io/ascii/core.py\nclass: RST\nline: 1719']


Current Line:
path: astropy/io/ascii/core.py
Current Line:
class: RST
Current Line:
line: 1719
Model Found Locs Separated:
['']


['']


['']


Compressed file contents:
{'astropy/io/ascii/qdp.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\ndef _line_type(line, delimiter=None):\n...\n\ndef _get_type_from_list_of_lines(lines, delimiter=None):\n...\n\ndef _get_lines_from_file(qdp_file):\n...\n\ndef _interpret_err_lines(err_specs, ncols, names=None):\n...\n\ndef _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n...\n\ndef _understand_err_col(colnames):\n...\n\ndef _read_table_qdp(qdp_file, names=None, table_id=None, delimiter=None):\n...\n\ndef _write_table_qdp(table, filename=None, err_specs=None):\n...\n\nclass QDPSplitter(core.DefaultSplitter):\n\n    delimiter = " "\n\n\nclass QDPHeader(basic.CommentedHeaderHeader):\n\n    splitter_class = QDPSplitter\n    comment = "!"\n    write_comment = "!"\n\n\nclass QDPData(basic.BasicData):\n\n    splitter_class = QDPSplitter\n    fill_values = [(core.masked, "NO")]\n    comment = "!"\n    write_comment = None\n\n\nclass QDP(basic.Basic):\n\n    _format_name = "qdp"\n    _io_registry_can_write = True\n    _io_registry_suffix = ".qdp"\n    _description = "Quick and Dandy Plotter"\n\n    header_class = QDPHeader\n    data_class = QDPData\n\n    def __init__(self, table_id=None, names=None, err_specs=None, sep=None):\n...\n    def read(self, table):\n...\n    def write(self, table):\n', 'astropy/table/table.py': '# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n_implementation_notes = """\nThis string has informal notes concerning Table implementation for developers.\n\nThings to remember:\n\n- Table has customizable attributes ColumnClass, Column, MaskedColumn.\n  Table.Column is normally just column.Column (same w/ MaskedColumn)\n  but in theory they can be different.  Table.ColumnClass is the default\n  class used to create new non-mixin columns, and this is a function of\n  the Table.masked attribute.  Column creation / manipulation in a Table\n  needs to respect these.\n\n- Column objects that get inserted into the Table.columns attribute must\n  have the info.parent_table attribute set correctly.  Beware just dropping\n  an object into the columns dict since an existing column may\n  be part of another Table and have parent_table set to point at that\n  table.  Dropping that column into `columns` of this Table will cause\n  a problem for the old one so the column object needs to be copied (but\n  not necessarily the data).\n\n  Currently replace_column is always making a copy of both object and\n  data if parent_table is set.  This could be improved but requires a\n  generic way to copy a mixin object but not the data.\n\n- Be aware of column objects that have indices set.\n\n- `cls.ColumnClass` is a property that effectively uses the `masked` attribute\n  to choose either `cls.Column` or `cls.MaskedColumn`.\n"""\n\n__doctest_skip__ = [\n    "Table.read",\n    "Table.write",\n    "Table._read",\n    "Table.convert_bytestring_to_unicode",\n    "Table.convert_unicode_to_bytestring",\n]\n\n__doctest_requires__ = {"*pandas": ["pandas>=1.1"]}\n\n_pprint_docs = """\n    {__doc__}\n\n    Parameters\n    ----------\n    max_lines : int or None\n        Maximum number of lines in table output.\n\n    max_width : int or None\n        Maximum character width of output.\n\n    show_name : bool\n        Include a header row for column names. Default is True.\n\n    show_unit : bool\n        Include a header row for unit.  Default is to show a row\n        for units only if one or more columns has a defined value\n        for the unit.\n\n    show_dtype : bool\n        Include a header row for column dtypes. Default is False.\n\n    align : str or list or tuple or None\n        Left/right alignment of columns. Default is right (None) for all\n        columns. Other allowed values are \'>\', \'<\', \'^\', and \'0=\' for\n        right, left, centered, and 0-padded, respectively. A list of\n        strings can be provided for alignment of tables with multiple\n        columns.\n    """\n\n_pformat_docs = """\n    {__doc__}\n\n    Parameters\n    ----------\n    max_lines : int or None\n        Maximum number of rows to output\n\n    max_width : int or None\n        Maximum character width of output\n\n    show_name : bool\n        Include a header row for column names. Default is True.\n\n    show_unit : bool\n        Include a header row for unit.  Default is to show a row\n        for units only if one or more columns has a defined value\n        for the unit.\n\n    show_dtype : bool\n        Include a header row for column dtypes. Default is True.\n\n    html : bool\n        Format the output as an HTML table. Default is False.\n\n    tableid : str or None\n        An ID tag for the table; only used if html is set.  Default is\n        "table{id}", where id is the unique integer id of the table object,\n        id(self)\n\n    align : str or list or tuple or None\n        Left/right alignment of columns. Default is right (None) for all\n        columns. Other allowed values are \'>\', \'<\', \'^\', and \'0=\' for\n        right, left, centered, and 0-padded, respectively. A list of\n        strings can be provided for alignment of tables with multiple\n        columns.\n\n    tableclass : str or list of str or None\n        CSS classes for the table; only used if html is set.  Default is\n        None.\n\n    Returns\n    -------\n    lines : list\n        Formatted table as a list of strings.\n    """\n\n\nclass TableReplaceWarning(UserWarning):\n\n    pass\n\n\ndef descr(col):\n...\n\ndef has_info_class(obj, cls):\n...\n\ndef _get_names_from_list_of_dict(rows):\n...\n\n# Note to future maintainers: when transitioning this to dict\n# be sure to change the OrderedDict ref(s) in Row and in __len__().\n\n\nclass TableColumns(OrderedDict):\n\n    def __init__(self, cols={}):\n...\n    def __getitem__(self, item):\n...\n    def __setitem__(self, item, value, validated=False):\n...\n    def __repr__(self):\n...\n    def _rename_column(self, name, new_name):\n...\n    def __delitem__(self, name):\n...\n    def isinstance(self, cls):\n...\n    def not_isinstance(self, cls):\n...\n\nclass TableAttribute(MetaAttribute):\n    pass\n\n\nclass PprintIncludeExclude(TableAttribute):\n\n    def __get__(self, instance, owner_cls):\n...\n    def __set__(self, instance, names):\n...\n    def __call__(self):\n...\n    def __repr__(self):\n...\n    def _add_remove_setup(self, names):\n...\n    def add(self, names):\n...\n    def remove(self, names):\n...\n    def _remove(self, names, raise_exc=False):\n...\n    def _rename(self, name, new_name):\n...\n    def set(self, names):\n...\n\nclass Table:\n\n    meta = MetaData(copy=False)\n\n    # Define class attributes for core container objects to allow for subclass\n    # customization.\n    Row = Row\n    Column = Column\n    MaskedColumn = MaskedColumn\n    TableColumns = TableColumns\n    TableFormatter = TableFormatter\n\n    # Unified I/O read and write methods from .connect\n    read = UnifiedReadWriteMethod(TableRead)\n    write = UnifiedReadWriteMethod(TableWrite)\n\n    pprint_exclude_names = PprintIncludeExclude()\n    pprint_include_names = PprintIncludeExclude()\n\n    def as_array(self, keep_byteorder=False, names=None):\n...\n    def __init__(\n        self,\n        data=None,\n        masked=False,\n        names=None,\n        dtype=None,\n        meta=None,\n        copy=True,\n        rows=None,\n        copy_indices=True,\n        units=None,\n        descriptions=None,\n        **kwargs,\n    ):\n...\n    def _set_column_attribute(self, attr, values):\n...\n    def __getstate__(self):\n...\n    def __setstate__(self, state):\n...\n    @property\n    def mask(self):\n...\n    @mask.setter\n    def mask(self, val):\n...\n    @property\n    def _mask(self):\n...\n    def filled(self, fill_value=None):\n...\n    @property\n    def indices(self):\n...\n    @property\n    def loc(self):\n...\n    @property\n    def loc_indices(self):\n...\n    @property\n    def iloc(self):\n...\n    def add_index(self, colnames, engine=None, unique=False):\n...\n    def remove_indices(self, colname):\n...\n    def index_mode(self, mode):\n...\n    def __array__(self, dtype=None):\n...\n    def _check_names_dtype(self, names, dtype, n_cols):\n...\n    def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):\n...\n    def _init_from_list(self, data, names, dtype, n_cols, copy):\n...\n    def _convert_data_to_col(\n        self, data, copy=True, default_name=None, dtype=None, name=None\n    ):\n...\n    def _init_from_ndarray(self, data, names, dtype, n_cols, copy):\n...\n    def _init_from_dict(self, data, names, dtype, n_cols, copy):\n...\n    def _get_col_cls_for_table(self, col):\n...\n    def _convert_col_for_table(self, col):\n...\n    def _init_from_cols(self, cols):\n...\n    def _new_from_slice(self, slice_):\n...\n    @staticmethod\n    def _make_table_from_cols(table, cols, verify=True, names=None):\n...\n    def _set_col_parent_table_and_mask(self, col):\n...\n    def itercols(self):\n...\n    def _base_repr_(\n        self,\n        html=False,\n        descr_vals=None,\n        max_width=None,\n        tableid=None,\n        show_dtype=True,\n        max_lines=None,\n        tableclass=None,\n    ):\n...\n    def _repr_html_(self):\n...\n    def __repr__(self):\n...\n    def __str__(self):\n...\n    def __bytes__(self):\n...\n    @property\n    def has_mixin_columns(self):\n...\n    @property\n    def has_masked_columns(self):\n...\n    @property\n    def has_masked_values(self):\n...\n    def _is_mixin_for_table(self, col):\n...\n    @format_doc(_pprint_docs)\n    def pprint(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        align=None,\n    ):\n...\n    @format_doc(_pprint_docs)\n    def pprint_all(\n        self,\n        max_lines=-1,\n        max_width=-1,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        align=None,\n    ):\n...\n    def _make_index_row_display_table(self, index_row_name):\n...\n    def show_in_notebook(\n        self,\n        tableid=None,\n        css=None,\n        display_length=50,\n        table_class="astropy-default",\n        show_row_index="idx",\n    ):\n...\n    def show_in_browser(\n        self,\n        max_lines=5000,\n        jsviewer=False,\n        browser="default",\n        jskwargs={"use_local_files": True},\n        tableid=None,\n        table_class="display compact",\n        css=None,\n        show_row_index="idx",\n    ):\n...\n    @format_doc(_pformat_docs, id="{id}")\n    def pformat(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        html=False,\n        tableid=None,\n        align=None,\n        tableclass=None,\n    ):\n...\n    @format_doc(_pformat_docs, id="{id}")\n    def pformat_all(\n        self,\n        max_lines=-1,\n        max_width=-1,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n        html=False,\n        tableid=None,\n        align=None,\n        tableclass=None,\n    ):\n...\n    def more(\n        self,\n        max_lines=None,\n        max_width=None,\n        show_name=True,\n        show_unit=None,\n        show_dtype=False,\n    ):\n...\n    def __getitem__(self, item):\n...\n    def __setitem__(self, item, value):\n...\n    def __delitem__(self, item):\n...\n    def _ipython_key_completions_(self):\n...\n    def field(self, item):\n...\n    @property\n    def masked(self):\n...\n    @masked.setter\n    def masked(self, masked):\n...\n    def _set_masked(self, masked):\n...\n    @property\n    def ColumnClass(self):\n...\n    @property\n    def dtype(self):\n...\n    @property\n    def colnames(self):\n...\n    @staticmethod\n    def _is_list_or_tuple_of_str(names):\n...\n    def keys(self):\n...\n    def values(self):\n...\n    def items(self):\n...\n    def __len__(self):\n...\n    def __or__(self, other):\n...\n    def __ior__(self, other):\n...\n    def index_column(self, name):\n...\n    def add_column(\n        self,\n        col,\n        index=None,\n        name=None,\n        rename_duplicate=False,\n        copy=True,\n        default_name=None,\n    ):\n...\n    def add_columns(\n        self, cols, indexes=None, names=None, copy=True, rename_duplicate=False\n    ):\n...\n    def _replace_column_warnings(self, name, col):\n...\n    def replace_column(self, name, col, copy=True):\n...\n    def remove_row(self, index):\n...\n    def remove_rows(self, row_specifier):\n...\n    def iterrows(self, *names):\n...\n    def _set_of_names_in_colnames(self, names):\n...\n    def remove_column(self, name):\n...\n    def remove_columns(self, names):\n...\n    def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):\n...\n    def convert_bytestring_to_unicode(self):\n...\n    def convert_unicode_to_bytestring(self):\n...\n    def keep_columns(self, names):\n...\n    def rename_column(self, name, new_name):\n...\n    def rename_columns(self, names, new_names):\n...\n    def _set_row(self, idx, colnames, vals):\n...\n    def add_row(self, vals=None, mask=None):\n...\n    def insert_row(self, index, vals=None, mask=None):\n...\n    def _replace_cols(self, columns):\n...\n    def update(self, other, copy=True):\n...\n    def argsort(self, keys=None, kind=None, reverse=False):\n...\n    def sort(self, keys=None, *, kind=None, reverse=False):\n...\n    def reverse(self):\n...\n    def round(self, decimals=0):\n...\n    def copy(self, copy_data=True):\n...\n    def __deepcopy__(self, memo=None):\n...\n    def __copy__(self):\n...\n    def __lt__(self, other):\n...\n    def __gt__(self, other):\n...\n    def __le__(self, other):\n...\n    def __ge__(self, other):\n...\n    def __eq__(self, other):\n...\n    def __ne__(self, other):\n...\n    def _rows_equal(self, other):\n...\n    def values_equal(self, other):\n...\n    @property\n    def groups(self):\n...\n    def group_by(self, keys):\n...\n    def to_pandas(self, index=None, use_nullable_int=True):\n...\n    @classmethod\n    def from_pandas(cls, dataframe, index=False, units=None):\n...\n    info = TableInfo()\n\n\nclass QTable(Table):\n\n    def _is_mixin_for_table(self, col):\n...\n    def _convert_col_for_table(self, col):\n'}














Model found locs
['path: astropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP']














Results Dict (contains filenames)
{'astropy/io/ascii/qdp.py': [], 'astropy/table/table.py': []}


Locs:
['path: astropy/io/ascii/qdp.py\nfunction: _line_type\nfunction: _get_type_from_list_of_lines\nfunction: _get_lines_from_file\nfunction: _interpret_err_lines\nfunction: _get_tables_from_qdp_file\nfunction: _understand_err_col\nfunction: _read_table_qdp\nfunction: _write_table_qdp\nclass: QDPSplitter\nclass: QDPHeader\nclass: QDPData\nclass: QDP']


Current Line:
path: astropy/io/ascii/qdp.py
Current Line:
function: _line_type
Current Line:
function: _get_type_from_list_of_lines
Current Line:
function: _get_lines_from_file
Current Line:
function: _interpret_err_lines
Current Line:
function: _get_tables_from_qdp_file
Current Line:
function: _understand_err_col
Current Line:
function: _read_table_qdp
Current Line:
function: _write_table_qdp
Current Line:
class: QDPSplitter
Current Line:
class: QDPHeader
Current Line:
class: QDPData
Current Line:
class: QDP
Model Found Locs Separated:
['']


['']


Results Dict (contains filenames)
{'astropy/io/ascii/qdp.py': [], 'astropy/table/table.py': []}


Locs:
['path: astropy/table/ascii.py\nfunction: _read_qdp\nline: 530\nline: 540']


Current Line:
path: astropy/table/ascii.py
Current Line:
function: _read_qdp
Current Line:
line: 530
Current Line:
line: 540
Model Found Locs Separated:
['']


['']


Results Dict (contains filenames)
{}


Locs:
['path: astropy/nddata/nddata.py\nline: 549\nline: 561\nline: 575\nline: 583']


Current Line:
path: astropy/nddata/nddata.py
Current Line:
line: 549
Current Line:
line: 561
Current Line:
line: 575
Current Line:
line: 583
Model Found Locs Separated:
